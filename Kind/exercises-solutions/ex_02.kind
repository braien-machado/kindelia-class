// type PairBool
// Contains 2 Booleans inside it
type PairBool { 
  new(fst: Bool, snd: Bool)
}

// Returns the first element of a pair
fst(pair: PairBool): Bool
  case pair {
    new: pair.fst
  }

// Returns the second element of a pair
snd(pair: PairBool): Bool
  case pair {
    new: pair.snd
  }

// Returns true if both elements of a PairBool are identical
eql_elements(a: PairBool): Bool 
  case a {
    new: case a.fst {
      true: a.snd
      false: case a.snd {
        true: Bool.false
        false: Bool.true
      }
    }
  }
  
// Returns true if both Pairs are equal 
// eql(PairBool.new(false, false), PairBool.new(true, true)) -> false 
// eql(PairBool.new(true, false), PairBool.new(true, false)) -> true
eql(a: PairBool, b: PairBool): Bool
  open a
  open b
  case eql_elements(PairBool.new(a.fst, b.fst)) {
    true: eql_elements(PairBool.new(a.snd, b.snd))
    false: Bool.false
  }

// Returns true if both Pairs are different
// eql(PairBool.new(false, false), PairBool.new(true, true)) -> true 
// eql(PairBool.new(true, false), PairBool.new(true, false)) -> false
not_eql(a: PairBool, b: PairBool): Bool
  case eql(a, b) {
    true: Bool.false
    false: Bool.true
  }
  
// Creates a PairBool from 2 Booleans
create(a: Bool, b: Bool): PairBool
  PairBool.new(a, b)

// Inverts the values of a PairBool
// neg(PairBool.new(false, false) -> PairBool.new(true, true)
// neg(PairBool.new(false, true) -> PairBool.new(true, false)
neg(pair: PairBool): PairBool
  open pair
  case pair.fst {
    true: case pair.snd {
      true: PairBool.new(false, false)
      false: PairBool.new(false, true)
    }
    false: case pair.snd {
      true: PairBool.new(true, false)
      false:  PairBool.new(true, true)
    }
  }

// Inverts the 2 elements of a PairBool
swap(pair: PairBool): PairBool 
  case pair {
    new: PairBool.new(pair.snd, pair.fst)
  }

ex_02: _
  let a1 = fst(PairBool.new(Bool.true, Bool.false)) // true
  let a2 = fst(PairBool.new(Bool.false, Bool.true)) // false
  let b1 = snd(PairBool.new(Bool.true, Bool.false)) // false
  let b2 = snd(PairBool.new(Bool.false, Bool.true)) // true
  let c1 = eql_elements(PairBool.new(Bool.false, Bool.true)) // false
  let c2 = eql_elements(PairBool.new(Bool.true, Bool.false)) // false
  let c3 = eql_elements(PairBool.new(Bool.false, Bool.false)) // true
  let c4 = eql_elements(PairBool.new(Bool.true, Bool.true)) // true
  let d1 = eql(PairBool.new(false, false), PairBool.new(true, true)) // false 
  let d2 = eql(PairBool.new(true, false), PairBool.new(true, false)) // true
  let d3 = eql(PairBool.new(true, true), PairBool.new(true, true)) // true 
  let d4 = eql(PairBool.new(false, true), PairBool.new(false, false)) // false
  let e1 = xor(PairBool.new(false, false), PairBool.new(true, true)) // true 
  let e2 = xor(PairBool.new(true, false), PairBool.new(true, false)) // false
  let e3 = xor(PairBool.new(true, true), PairBool.new(true, true)) // false
  let e4 = xor(PairBool.new(false, true), PairBool.new(false, false)) // true
  let f = create(Bool.true, Bool.false) // PairBool.new(Bool.true, Bool.false)
  let g1 = neg(PairBool.new(false, true)) // PairBool.new(true, false)
  let g2 = neg(PairBool.new(false, false)) // PairBool.new(true, true)
  let h = swap(PairBool.new(false, true)) // PairBool.new(true, false)

  // List.show!(Bool.show [a1, a2, b1, b2, c1, c2, c3, c4, d1, d2, d3, d4, e1, e2, e3, e4])
  // f
  // g1
  // g2
  h
